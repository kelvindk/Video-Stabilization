#include "boost/throw_exception.hpp"
#include "boost/exception/info.hpp"
#include "boost/bind.hpp"
#include <string>
#include <map>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <limits>
#include <assert.h>

#define NL "\n"
#define TAB "    "
#define TAB1 TAB
#define TAB2 TAB TAB
#define TAB3 TAB TAB TAB
#define TAB4 TAB TAB TAB TAB
#define NAMESPACE_BEGIN "namespace"NL"boost"NL TAB1"{"NL TAB"namespace"NL TAB1"la"NL TAB2"{"NL
#define NAMESPACE_END TAB2"}"NL TAB1"}"NL
#define INCLUDE_GUARD_END NL"#endif"NL
#define INCLUDE_MATH\
	"#include <boost/la/math.hpp>"NL
#define INCLUDE_MATRIX_TRAITS\
	"#include <boost/la/matrix_traits.hpp>"NL
#define INCLUDE_VECTOR_TRAITS\
	"#include <boost/la/vector_traits.hpp>"NL
#define INCLUDE_QUATERNION_TRAITS\
	"#include <boost/la/quaternion_traits.hpp>"NL
#define INCLUDE_ENABLE_IF\
	"#include <boost/utility/enable_if.hpp>"NL
#define INCLUDE_STATIC_ASSERT\
	"#include <boost/static_assert.hpp>"NL
#define INCLUDE_DEDUCE_SCALAR\
	"#include <boost/la/deduce_scalar.hpp>"NL
#define INCLUDE_DEDUCE_VECTOR\
	"#include <boost/la/deduce_vector.hpp>"NL
#define INCLUDE_DEDUCE_MATRIX\
	"#include <boost/la/deduce_matrix.hpp>"NL
#define INCLUDE_SCALAR_TRAITS\
	"#include <boost/la/scalar_traits.hpp>"NL
#define INCLUDE_SWIZZLE_TRAITS\
	"#include <boost/la/detail/swizzle_traits.hpp>"NL
#define INCLUDE_ASSERT\
	"#include <boost/assert.hpp>"NL
#define FOOTER NAMESPACE_END INCLUDE_GUARD_END

namespace
	{
	struct exception_base: virtual std::exception, virtual boost::exception { };
	struct bad_command_line: virtual exception_base { };
	typedef boost::error_info<struct cmd_arg_,std::string> cmd_arg;

	struct
	null_deleter
		{
		template <class T>
		void
		operator()( T * ) const
			{
			}
		};

	struct
	include_guard_filter
		{
		void
		operator()( char & x )
			{
			if( x>='a' && x<='z' )
				x-='a'-'A';
			if( x=='.' )
				x='_';
			}
		};

	template <class T>
	std::ostream &
	operator<<( boost::shared_ptr<std::ostream> const & out, T const & x )
		{
		return (*out)<<x;
		}

	template <class T>
	std::string
	to_string( T const & x )
		{
		std::ostringstream s;
		s<<x;
		return s.str();
		}

	struct
	command_line_options
		{
		bool con;
		std::string output_directory;
		mutable std::map<std::string,std::vector<std::string> > gen;

		command_line_options():
			con(false)
			{
			}

		boost::shared_ptr<std::ostream>
		stream( std::string const & name, int m, int n=0, int p=0 ) const
			{
			assert(m>0);
			assert(n>=0);
			assert(p>=0);
			std::string path=name;
			path += '_';
			path += to_string(m);
			if( n )
				{
				path+='_';
				path+=to_string(n);
				}
			if( p )
				{
				path+='_';
				path+=to_string(p);
				}
			path += ".hpp";
			std::vector<std::string> & generated_versions=gen[name];
			assert( generated_versions.end()==std::find(generated_versions.begin(),generated_versions.end(),path) );
			generated_versions.push_back(path);
			return open(path);
			}

		void
		out_gen_headers() const
			{
			std::for_each(gen.begin(),gen.end(),
				boost::bind(&command_line_options::out_gen_header,this,_1));
			}

		void
		out_gen_header( std::pair<std::string const,std::vector<std::string> > const & h ) const
			{
			boost::shared_ptr<std::ostream> s=open(h.first+".hpp");
			std::for_each(h.second.begin(),h.second.end(),
				boost::bind(out_include,s,_1));
			s<<INCLUDE_GUARD_END;
			}

		static
		void
		out_include( boost::shared_ptr<std::ostream> const & s, std::string const & name )
			{
			s << "#include <boost/la/custom/"+name+">"NL;
			}

		boost::shared_ptr<std::ostream>
		open( std::string const & name ) const
			{
			assert(!name.empty());
			boost::shared_ptr<std::ostream> out;
			if( con )
				{
				out=boost::shared_ptr<std::ostream>(&std::cout,null_deleter());
				(*out) << "//*** " << name << " ***"NL NL;
				}
			else
				{
				std::string path;
				if( !output_directory.empty() )
					{
					path+=output_directory;
					path+='/';
					path+=name;
					}
				out=boost::shared_ptr<std::ofstream>(new std::ofstream(path.c_str()));
				std::cout << "Writing " << path << "..." << std::endl;
				}
			std::string include_guard_name="BOOST_LA_CUSTOM_";
			include_guard_name+=name;
			include_guard_name+="_INCLUDED"NL;
			std::for_each(include_guard_name.begin(),include_guard_name.end(),include_guard_filter());
			(*out) <<
				"//Copyright (c) 2009 Emil Dotchevski and Reverge Studios, Inc."NL NL
				"//Distributed under the Boost Software License, Version 1.0. (See accompanying"NL
				"//file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"NL NL
				"#ifndef " << include_guard_name <<
				"#define " << include_guard_name <<
				NL "//This file was generated by a program. Do not edit manually."NL NL
				"#include <boost/la/config.hpp>"NL
				;
			return out;
			}
		};

	void
	replace( std::string & s, char const * substr, char const * newstr )
		{
		assert(substr && *substr);
		assert(newstr && *newstr);
		std::string::size_type f=s.find(substr);
		if( s.npos!=f )
			s.replace(f,f+strlen(substr),newstr);
		}

	std::string
	deduce_name( std::string const & fn, char const * left, char const * right )
		{
		assert(left!=0);
		if( !right )
			right=left;
		std::string s=fn;
		replace(s,"operator==","eq");
		replace(s,"operator!=","neq");
		replace(s,"operator+=","plus_eq");
		replace(s,"operator-=","minus_eq");
		replace(s,"operator*=","mul_eq");
		replace(s,"operator/=","div_eq");
		replace(s,"operator+","plus");
		replace(s,"operator-","minus");
		replace(s,"operator*","mul");
		replace(s,"operator/","div");
		std::string r=left;
		if( !r.empty() )
			r += '_';
		r += s;
		if( *right )
			{
			r += '_';
			r += right;
			}
		return r;
		}

	void
	header_mr_ma_mb_same_size( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_MATRIX
			INCLUDE_ENABLE_IF
			INCLUDE_STATIC_ASSERT
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<r<<" && matrix_traits<B>::rows=="<<r<<" &&"NL
			TAB3"matrix_traits<A>::cols=="<<c<<" && matrix_traits<B>::cols=="<<c<<","NL
			TAB3"deduce_matrix2<A,B,"<<r<<','<<c<<"> >::type"NL
			TAB2<<name<<"( A const & a, B const & b )"NL
		;
		}

	void
	header_mr_ma_mb_mult( std::ostream & g, int m, int n, int p, std::string const & name )
		{
		assert(m>0);
		assert(n>0);
		assert(p>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_MATRIX
			INCLUDE_ENABLE_IF
			INCLUDE_STATIC_ASSERT
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<m<<" && matrix_traits<B>::rows=="<<n<<" &&"NL
			TAB3"matrix_traits<A>::cols=="<<n<<" && matrix_traits<B>::cols=="<<p<<","NL
			TAB3"deduce_matrix2<A,B,"<<m<<','<<p<<"> >::type"NL
			TAB2<<name<<"( A const & a, B const & b )"NL
		;
		}

	void
	header_vr_ma_vb_mult( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_VECTOR
			INCLUDE_ENABLE_IF
			INCLUDE_STATIC_ASSERT
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<r<<" && matrix_traits<A>::cols=="<<c<<" &&"NL
			TAB3"vector_traits<B>::dim=="<<c<<","NL
			TAB3"deduce_vector2<A,B,"<<c<<"> >::type"NL
			TAB2<<name<<"( A const & a, B const & b )"NL
		;
		}

	void
	header_vr_va_mb_mult( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_VECTOR
			INCLUDE_ENABLE_IF
			INCLUDE_STATIC_ASSERT
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"matrix_traits<B>::rows=="<<r<<" && matrix_traits<B>::cols=="<<c<<" &&"NL
			TAB3"vector_traits<A>::dim=="<<c<<","NL
			TAB3"deduce_vector2<A,B,"<<r<<"> >::type"NL
			TAB2<<name<<"( A const & a, B const & b )"NL
		;
		}

	void
	header_vr_va_vb_same_size( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_VECTOR
			INCLUDE_ENABLE_IF
			INCLUDE_STATIC_ASSERT
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"vector_traits<A>::dim=="<<d<<" && vector_traits<B>::dim=="<<d<<","NL
			TAB3"deduce_vector2<A,B,"<<d<<"> >::type"NL
			TAB2<<name<<"( A const & a, B const & b )"NL
		;
		}

	void
	header_bool_ma_mb_same_size( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_MATRIX_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<r<<" && matrix_traits<B>::rows=="<<r<<" &&"NL
			TAB3"matrix_traits<A>::cols=="<<c<<" && matrix_traits<B>::cols=="<<c<<","NL
			TAB3"bool>::type"NL
			TAB2<<name<<"( A const & a, B const & b )"NL
		;
		}

	void
	header_bool_va_vb_same_size( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_VECTOR_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"vector_traits<A>::dim=="<<d<<" && vector_traits<B>::dim=="<<d<<","NL
			TAB2"bool>::type"NL
			TAB2<<name<<"( A const & a, B const & b )"NL
		;
		}

	void
	header_ma_mb_same_size( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_MATRIX_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<r<<" && matrix_traits<B>::rows=="<<r<<" &&"NL
			TAB3"matrix_traits<A>::cols=="<<c<<" && matrix_traits<B>::cols=="<<c<<","NL
			TAB3"A &>::type"NL
			TAB2<<name<<"( A & a, B const & b )"NL
		;
		}

	void
	header_va_vb_same_size( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_VECTOR_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"vector_traits<A>::dim=="<<d<<" && vector_traits<B>::dim=="<<d<<","NL
			TAB3"A &>::type"NL
			TAB2<<name<<"( A & a, B const & b )"NL
		;
		}

	void
	header_sr_ma( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_MATRIX_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<r<<" && matrix_traits<A>::cols=="<<c<<","NL
			TAB3"typename matrix_traits<A>::scalar_type>::type"NL
			TAB2<<name<<"( A const & a )"NL
		;
		}

	void
	header_sr_va_vb( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_VECTOR_TRAITS
			INCLUDE_DEDUCE_SCALAR
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A,class B>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"vector_traits<A>::dim=="<<d<<" && vector_traits<B>::dim=="<<d<<","NL
			TAB3"deduce_scalar<typename vector_traits<A>::scalar_type,typename vector_traits<B>::scalar_type> >::type"NL
			TAB2<<name<<"( A const & a, B const & b )"NL
		;
		}

	void
	header_sr_va( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_VECTOR_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"is_vector<A>::value && vector_traits<A>::dim=="<<d<<","NL
			TAB3"typename vector_traits<A>::scalar_type>::type"NL
			TAB2<<name<<"( A const & a )"NL
		;
		}

	void
	header_mr_ma( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_MATRIX
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<r<<" && matrix_traits<A>::cols=="<<c<<","NL
			TAB3"deduce_matrix<A> >::type"NL
			TAB2<<name<<"( A const & a )"NL
		;
		}

	void
	header_ma_inverse( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_ENABLE_IF
			INCLUDE_DEDUCE_MATRIX
			INCLUDE_SCALAR_TRAITS
			INCLUDE_ASSERT
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<d<<" && matrix_traits<A>::cols=="<<d<<","NL
			TAB3"deduce_matrix<A> >::type"NL
			TAB2<<name<<"( A const & a, typename matrix_traits<A>::scalar_type det )"NL
		;
		}

	void
	header_vr_va( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_VECTOR
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"vector_traits<A>::dim=="<<d<<","NL
			TAB3"deduce_vector<A> >::type"NL
			TAB2<<name<<"( A const & a )"NL
		;
		}

	void
	header_mr_ma_same_size( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_MATRIX_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class R,class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"matrix_traits<R>::rows=="<<r<<" && matrix_traits<A>::rows=="<<r<<" &&"NL
			TAB3"matrix_traits<R>::cols=="<<c<<" && matrix_traits<A>::cols=="<<c<<","NL
			TAB3"R>::type"NL
			TAB2<<name<<"( A const & a )"NL
		;
		}

	void
	header_vr_va_same_size( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_VECTOR_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class R,class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"is_vector<A>::value &&"NL
			TAB3"vector_traits<R>::dim=="<<d<<" && vector_traits<A>::dim=="<<d<<","NL
			TAB3"R>::type"NL
			TAB2<<name<<"( A const & a )"NL
		;
		}

	void
	header_mr( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_MATRIX_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class R>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"is_matrix<R>::value,"NL
			TAB3"R>::type"NL
			TAB2<<name<<"()"NL
		;
		}

	void
	header_vr( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_VECTOR_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class R>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"is_vector<R>::value,"NL
			TAB3"R>::type"NL
			TAB2<<name<<"()"NL
		;
		}

	void
	header_mr_ma_sb( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_MATRIX
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<r<<" && matrix_traits<A>::cols=="<<c<<","NL
			TAB3"deduce_matrix<A> >::type"NL
			TAB2<<name<<"( A const & a, typename matrix_traits<A>::scalar_type b )"NL
		;
		}

	void
	header_vr_va_sb( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_DEDUCE_VECTOR
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename lazy_enable_if_c<"NL
			TAB3"vector_traits<A>::dim=="<<d<<","NL
			TAB3"deduce_vector<A> >::type"NL
			TAB2<<name<<"( A const & a, typename vector_traits<A>::scalar_type b )"NL
		;
		}

	void
	header_ma_sb( std::ostream & g, int r, int c, std::string const & name )
		{
		assert(r>0);
		assert(c>0);
		assert(!name.empty());
		g<<
			INCLUDE_MATRIX_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"matrix_traits<A>::rows=="<<r<<" && matrix_traits<A>::cols=="<<c<<","NL
			TAB3"A &>::type"NL
			TAB2<<name<<"( A & a, typename matrix_traits<A>::scalar_type b )"NL
		;
		}

	void
	header_va_sb( std::ostream & g, int d, std::string const & name )
		{
		assert(d>0);
		assert(!name.empty());
		g<<
			INCLUDE_VECTOR_TRAITS
			INCLUDE_ENABLE_IF
			NL
			NAMESPACE_BEGIN
			TAB2"template <class A>"NL
			TAB2"BOOST_LA_INLINE_OPERATIONS"NL
			TAB2"typename enable_if_c<"NL
			TAB3"vector_traits<A>::dim=="<<d<<","NL
			TAB3"A &>::type"NL
			TAB2<<name<<"( A & a, typename vector_traits<A>::scalar_type b )"NL
		;
		}

	void
	defined( std::ostream & g, int m, int n, int p, std::string const & dn )
		{
		assert(m>0);
		assert(n>0);
		assert(p>0);
		assert(!dn.empty());
		std::string name=dn+"_defined";
		g<<
			NL
			TAB2"namespace"NL
			TAB2"la_detail"NL
			TAB3"{"NL
			TAB3"template <int M,int N,int P>"NL
			TAB3"struct "<<name<<";"NL
			NL
			TAB3"template <>"NL
			TAB3"struct"NL
			TAB3<<name<<'<'<<m<<','<<n<<','<<p<<">"NL
			TAB4"{"NL
			TAB4"static bool const value=true;"NL
			TAB4"};"NL
			TAB3"}"NL
			;
		}

	void
	defined( std::ostream & g, int r, int c, std::string const & dn )
		{
		assert(r>0);
		assert(c>0);
		assert(!dn.empty());
		std::string name=dn+"_defined";
		g<<
			NL
			TAB2"namespace"NL
			TAB2"la_detail"NL
			TAB3"{"NL
			TAB3"template <int M,int N>"NL
			TAB3"struct "<<name<<";"NL
			NL
			TAB3"template <>"NL
			TAB3"struct"NL
			TAB3<<name<<"<"<<r<<","<<c<<">"NL
			TAB4"{"NL
			TAB4"static bool const value=true;"NL
			TAB4"};"NL
			TAB3"}"NL
			;
		}

	void
	defined( std::ostream & g, int d, std::string const & dn )
		{
		assert(d>0);
		assert(!dn.empty());
		std::string name=dn+"_defined";
		g<<
			NL
			TAB2"namespace"NL
			TAB2"la_detail"NL
			TAB3"{"NL
			TAB3"template <int D>"NL
			TAB3"struct "<<name<<";"NL
			NL
			TAB3"template <>"NL
			TAB3"struct"NL
			TAB3<<name<<"<"<<d<<">"NL
			TAB4"{"NL
			TAB4"static bool const value=true;"NL
			TAB4"};"NL
			TAB3"}"NL
			;
		}

	void
	mr_mult_ma_mb( command_line_options const & opt, int m, int n, int p )
		{
		assert(m>0);
		assert(n>0);
		assert(p>0);
		std::string dn=deduce_name("operator*","matrix",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,m,n,p);
		header_mr_ma_mb_mult(*g,m,n,p,"operator*");
		g<<
			TAB3"{"NL
			TAB3"typedef typename matrix_traits<A>::scalar_type Ta;"NL
			TAB3"typedef typename matrix_traits<B>::scalar_type Tb;"NL
			;
		for( int i=0; i!=m; ++i )
			for( int j=0; j!=n; ++j )
				g<<TAB3"Ta const a"<<i<<j<<" = matrix_traits<A>::template r<"<<i<<','<<j<<">(a);"NL;
		for( int i=0; i!=n; ++i )
			for( int j=0; j!=p; ++j )
				g<<TAB3"Tb const b"<<i<<j<<" = matrix_traits<B>::template r<"<<i<<','<<j<<">(b);"NL;
		g<<
			TAB3"typedef typename deduce_matrix2<A,B,"<<m<<','<<p<<">::type R;"NL
			TAB3"BOOST_STATIC_ASSERT(matrix_traits<R>::rows=="<<m<<");"NL
			TAB3"BOOST_STATIC_ASSERT(matrix_traits<R>::cols=="<<p<<");"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=m; ++i )
			for( int j=0; j!=p; ++j )
				{
				g<<TAB3"matrix_traits<R>::template w<"<<i<<","<<j<<">(r)=";
				for( int k=0; k!=n; ++k )
					{
					if( k )
						g<<'+';
					g<<'a'<<i<<k<<"*b"<<k<<j;
					}
				g<<";"NL;
				}
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,m,n,p,dn);
		g<<FOOTER;
		}

	void
	ma_mult_ma_mb( command_line_options const & opt, int d )
		{
		assert(d>0);
		std::string dn=deduce_name("operator*=","matrix",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_ma_mb_same_size(*g,d,d,"operator*=");
		g<<
			TAB3"{"NL
			TAB3"typedef typename matrix_traits<A>::scalar_type Ta;"NL
			TAB3"typedef typename matrix_traits<B>::scalar_type Tb;"NL
			;
		for( int i=0; i!=d; ++i )
			for( int j=0; j!=d; ++j )
				g<<TAB3"Ta const a"<<i<<j<<" = matrix_traits<A>::template r<"<<i<<','<<j<<">(a);"NL;
		for( int i=0; i!=d; ++i )
			for( int j=0; j!=d; ++j )
				g<<TAB3"Tb const b"<<i<<j<<" = matrix_traits<B>::template r<"<<i<<','<<j<<">(b);"NL;
		for( int i=0; i!=d; ++i )
			for( int j=0; j!=d; ++j )
				{
				g<<TAB3"matrix_traits<A>::template w<"<<i<<","<<j<<">(a)=";
				for( int k=0; k!=d; ++k )
					{
					if( k )
						g<<'+';
					g<<'a'<<i<<k<<"*b"<<k<<j;
					}
				g<<";"NL;
				}
		g<<
			TAB3"return a;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	vr_mult_ma_vb( command_line_options const & opt, int r, int c )
		{
		assert(r>0);
		assert(c>0);
		std::string dn=deduce_name("operator*","matrix","vector");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_vr_ma_vb_mult(*g,r,c,"operator*");
		g<<
			TAB3"{"NL
			TAB3"typedef typename matrix_traits<A>::scalar_type Ta;"NL
			TAB3"typedef typename vector_traits<B>::scalar_type Tb;"NL
			;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"Ta const a"<<i<<j<<" = matrix_traits<A>::template r<"<<i<<','<<j<<">(a);"NL;
		for( int i=0; i!=c; ++i )
			g<<TAB3"Tb const b"<<i<<" = vector_traits<B>::template r<"<<i<<">(b);"NL;
		g<<
			TAB3"typedef typename deduce_vector2<A,B,"<<c<<">::type R;"NL
			TAB3"BOOST_STATIC_ASSERT(vector_traits<R>::dim=="<<c<<");"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=r; ++i )
			{
			g<<TAB3"vector_traits<R>::template w<"<<i<<">(r)=";
			for( int j=0; j!=c; ++j )
				{
				if( j )
					g<<'+';
				g<<'a'<<i<<j<<"*b"<<j;
				}
			g<<";"NL;
			}
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	vr_mult_va_mb( command_line_options const & opt, int r, int c )
		{
		assert(r>0);
		assert(c>0);
		std::string dn=deduce_name("operator*","vector","matrix");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_vr_va_mb_mult(*g,r,c,"operator*");
		g<<
			TAB3"{"NL
			TAB3"typedef typename vector_traits<A>::scalar_type Ta;"NL
			TAB3"typedef typename matrix_traits<B>::scalar_type Tb;"NL
			;
		for( int i=0; i!=r; ++i )
			g<<TAB3"Ta const a"<<i<<" = vector_traits<A>::template r<"<<i<<">(a);"NL;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"Tb const b"<<i<<j<<" = matrix_traits<B>::template r<"<<i<<','<<j<<">(b);"NL;
		g<<
			TAB3"typedef typename deduce_vector2<A,B,"<<r<<">::type R;"NL
			TAB3"BOOST_STATIC_ASSERT(vector_traits<R>::dim=="<<r<<");"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=c; ++i )
			{
			g<<TAB3"vector_traits<R>::template w<"<<i<<">(r)=";
			for( int j=0; j!=r; ++j )
				{
				if( j )
					g<<'+';
				g<<'a'<<j<<"*b"<<j<<i;
				}
			g<<";"NL;
			}
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	vr_op_va_vb_same_size( command_line_options const & opt, int d, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"vector",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_vr_va_vb_same_size(*g,d,fn);
		g<<
			TAB3"{"NL
			TAB3"typedef typename deduce_vector2<A,B,"<<d<<">::type R;"NL
			TAB3"BOOST_STATIC_ASSERT(vector_traits<R>::dim=="<<d<<");"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=d; ++i )
			g<<TAB3"vector_traits<R>::template w<"<<i<<">(r)=vector_traits<A>::template r<"<<i<<">(a)"<<op<<"vector_traits<B>::template r<"<<i<<">(b);"NL;
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	bool_eq_ma_mb( command_line_options const & opt, int r, int c )
		{
		std::string dn=deduce_name("operator==","matrix",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_bool_ma_mb_same_size(*g,r,c,"operator==");
		g<<
			TAB3"{"NL
			TAB3"return"NL
			;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<
					TAB4"matrix_traits<A>::template r<"<<i<<','<<j<<">(a)==matrix_traits<B>::template r<"<<i<<','<<j<<">(b)"<<(i!=r-1||j!=c-1?" &&":";")<<NL;
					;
		g<<
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	bool_eq_va_vb( command_line_options const & opt, int d )
		{
		std::string dn=deduce_name("operator==","vector",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_bool_va_vb_same_size(*g,d,"operator==");
		g<<
			TAB3"{"NL
			TAB3"return"NL
			;
		for( int i=0; i!=d; ++i )
			g<<
				TAB4"vector_traits<A>::template r<"<<i<<">(a)==vector_traits<B>::template r<"<<i<<">(b)"<<(i!=d-1?" &&":";")<<NL;
				;
		g<<
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	bool_neq_ma_mb( command_line_options const & opt, int r, int c )
		{
		std::string dn=deduce_name("operator!=","matrix",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_bool_ma_mb_same_size(*g,r,c,"operator!=");
		g<<
			TAB3"{"NL
			TAB3"return"NL
			;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<
					TAB4"!(matrix_traits<A>::template r<"<<i<<','<<j<<">(a)==matrix_traits<B>::template r<"<<i<<','<<j<<">(b))"<<(i!=r-1||j!=c-1?" ||":";")<<NL;
					;
		g<<
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	bool_neq_va_vb( command_line_options const & opt, int d )
		{
		std::string dn=deduce_name("operator!=","vector",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_bool_va_vb_same_size(*g,d,"operator!=");
		g<<
			TAB3"{"NL
			TAB3"return"NL
			;
		for( int i=0; i!=d; ++i )
			g<<
				TAB4"!(vector_traits<A>::template r<"<<i<<">(a)==vector_traits<B>::template r<"<<i<<">(b))"<<(i!=d-1?" ||":";")<<NL;
				;
		g<<
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	mr_op_ma_mb_same_size( command_line_options const & opt, int r, int c, std::string const & fn, std::string const & op )
		{
		assert(r>0);
		assert(c>0);
		assert(!op.empty());
		std::string dn=deduce_name(fn,"matrix",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_mr_ma_mb_same_size(*g,r,c,fn);
		g<<
			TAB3"{"NL
			TAB3"typedef typename deduce_matrix2<A,B,"<<r<<','<<c<<">::type R;"NL
			TAB3"BOOST_STATIC_ASSERT(matrix_traits<R>::rows=="<<r<<");"NL
			TAB3"BOOST_STATIC_ASSERT(matrix_traits<R>::cols=="<<c<<");"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"matrix_traits<R>::template w<"<<i<<","<<j<<">(r)=matrix_traits<A>::template r<"<<i<<","<<j<<">(a)"<<op<<"matrix_traits<B>::template r<"<<i<<","<<j<<">(b);"NL;
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	ma_op_ma_mb_same_size( command_line_options const & opt, int r, int c, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"matrix",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_ma_mb_same_size(*g,r,c,fn);
		g<<TAB3"{"NL;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"matrix_traits<A>::template w<"<<i<<","<<j<<">(a)"<<op<<"matrix_traits<B>::template r<"<<i<<","<<j<<">(b);"NL;
		g<<
			TAB3"return a;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	va_op_va_vb_same_size( command_line_options const & opt, int d, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"vector",0);
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_va_vb_same_size(*g,d,fn);
		g<<TAB3"{"NL;
		for( int i=0; i!=d; ++i )
			g<<TAB3"vector_traits<A>::template w<"<<i<<">(a)"<<op<<"vector_traits<B>::template r<"<<i<<">(b);"NL;
		g<<
			TAB3"return a;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	mr_op_ma( command_line_options const & opt, int r, int c, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"matrix","");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_mr_ma(*g,r,c,fn);
		g<<
			TAB3"{"NL
			TAB3"typedef typename deduce_matrix<A>::type R;"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"matrix_traits<R>::template w<"<<i<<","<<j<<">(r)="<<op<<"matrix_traits<A>::template r<"<<i<<","<<j<<">(a);"NL;
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	vr_op_va( command_line_options const & opt, int d, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"vector","");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_vr_va(*g,d,fn);
		g<<
			TAB3"{"NL
			TAB3"typedef typename deduce_vector<A>::type R;"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=d; ++i )
			g<<TAB3"vector_traits<R>::template w<"<<i<<">(r)="<<op<<"vector_traits<A>::template r<"<<i<<">(a);"NL;
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	mr_op_ma_sb( command_line_options const & opt, int r, int c, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"matrix","scalar");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_mr_ma_sb(*g,r,c,fn);
		g<<
			TAB3"{"NL
			TAB3"typedef typename deduce_matrix<A>::type R;"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"matrix_traits<R>::template w<"<<i<<","<<j<<">(r)=matrix_traits<A>::template r<"<<i<<","<<j<<">(a)"<<op<<"b;"NL;
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	vr_op_va_sb( command_line_options const & opt, int d, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"vector","scalar");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_vr_va_sb(*g,d,fn);
		g<<
			TAB3"{"NL
			TAB3"typedef typename deduce_vector<A>::type R;"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=d; ++i )
			g<<TAB3"vector_traits<R>::template w<"<<i<<">(r)=vector_traits<A>::template r<"<<i<<">(a)"<<op<<"b;"NL;
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	ma_op_ma_sb( command_line_options const & opt, int r, int c, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"matrix","scalar");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_ma_sb(*g,r,c,fn);
		g<<
			TAB3"{"NL
			;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"matrix_traits<A>::template w<"<<i<<","<<j<<">(a)"<<op<<"b;"NL;
		g<<
			TAB3"return a;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	va_op_va_sb( command_line_options const & opt, int d, std::string const & fn, std::string const & op )
		{
		assert(!op.empty());
		std::string dn=deduce_name(fn,"vector","scalar");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_va_sb(*g,d,fn);
		g<<
			TAB3"{"NL
			;
		for( int i=0; i!=d; ++i )
			g<<TAB3"vector_traits<A>::template w<"<<i<<">(a)"<<op<<"b;"NL;
		g<<
			TAB3"return a;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	ma_assign_ma_mb( command_line_options const & opt, int r, int c )
		{
		std::string dn=deduce_name("assign","matrix","");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,r,c);
		header_ma_mb_same_size(*g,r,c,"assign");
		g<<TAB3"{"NL;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"matrix_traits<A>::template w<"<<i<<","<<j<<">(a)=matrix_traits<B>::template r<"<<i<<","<<j<<">(b);"NL;
		g<<
			TAB3"return a;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,dn);
		g<<FOOTER;
		}

	void
	va_assign_va_vb( command_line_options const & opt, int d )
		{
		boost::shared_ptr<std::ostream> g=opt.stream("vector_assign",d);
		header_va_vb_same_size(*g,d,"assign");
		g<<TAB3"{"NL;
		for( int i=0; i!=d; ++i )
			g<<TAB3"vector_traits<A>::template w<"<<i<<">(a)=vector_traits<B>::template r<"<<i<<">(b);"NL;
		g<<
			TAB3"return a;"NL
			TAB3"}"NL
			;
		defined(*g,d,"vector_assign");
		g<<FOOTER;
		}

	void
	mr_make_ma( command_line_options const & opt, int r, int c )
		{
		boost::shared_ptr<std::ostream> g=opt.stream("matrix_make",r,c);
		header_mr_ma_same_size(*g,r,c,"make");
		g<<TAB3"{"NL<<
			TAB3"R r;"NL
			;
		for( int i=0; i!=r; ++i )
			for( int j=0; j!=c; ++j )
				g<<TAB3"matrix_traits<R>::template w<"<<i<<","<<j<<">(r)=matrix_traits<A>::template r<"<<i<<","<<j<<">(a);"NL;
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,r,c,"matrix_make");
		g<<FOOTER;
		}

	void
	vr_make_va( command_line_options const & opt, int d )
		{
		boost::shared_ptr<std::ostream> g=opt.stream("vector_make",d);
		header_vr_va_same_size(*g,d,"make");
		g<<TAB3"{"NL<<
			TAB3"R r;"NL
			;
		for( int i=0; i!=d; ++i )
			g<<TAB3"vector_traits<R>::template w<"<<i<<">(r)=vector_traits<A>::template r<"<<i<<">(a);"NL;
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,d,"vector_make");
		g<<FOOTER;
		}

	struct
	delrc
		{
		delrc const * next;
		int i, j;
		char var;
		explicit
		delrc( char var ):
			next(0),
			i(std::numeric_limits<int>::max()),
			j(std::numeric_limits<int>::max()),
			var(var)
			{
			}
		delrc( delrc const & next, int i, int j ):
			next(&next),
			i(i),
			j(j),
			var(next.var)
			{
			}
		std::pair<int,int>
		idx( std::pair<int,int> const & x ) const
			{
			std::pair<int,int> r(x.first+(x.first>=i),x.second+(x.second>=j));
			if( next )
				return next->idx(r);
			else
				return r;

			}
		void
		operator()( std::ostream & g, int r, int c ) const
			{
			std::pair<int,int> p=idx(std::make_pair(r,c));
			g << var << p.first << p.second;
			}
		};

	void
	determinant_impl( std::ostream & g, int n, delrc const & a )
		{
		if( n==1 )
			return a(g,0,0);
		g << "(";
		char const * plus="";
		for( int i=0; i!=n; ++i,plus="+" )
			{
			g<<((i&1)?"-":plus);
			a(g,0,i);
			g<<'*';
			determinant_impl(g,n-1,delrc(a,0,i));
			}
		g << ")";
		}

	void
	determinant( command_line_options const & opt, int d )
		{
		std::string dn=deduce_name("determinant","matrix","");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_sr_ma(*g,d,d,"determinant");
		g<<
			TAB3"{"NL
			TAB3"typedef typename matrix_traits<A>::scalar_type T;"NL
			;
		for( int i=0; i!=d; ++i )
			for( int j=0; j!=d; ++j )
				g<<TAB3<<"T const a"<<i<<j<<"=matrix_traits<A>::template r<"<<i<<','<<j<<">(a);"NL;
		g<<TAB3"T det=";
		determinant_impl(*g,d,delrc('a'));
		g<<";"NL;
		g<<
			TAB3"return det;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	inverse_ma( command_line_options const & opt, int d )
		{
		assert(d>1);
		std::string dn=deduce_name("inverse","matrix","");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_ma_inverse(*g,d,"inverse");
		g<<
			TAB3"{"NL
			TAB3"typedef typename matrix_traits<A>::scalar_type T;"NL
			TAB3"BOOST_ASSERT(det!=scalar_traits<T>::zero());"NL
			;
		for( int i=0; i!=d; ++i )
			for( int j=0; j!=d; ++j )
				g<<TAB3"T const a"<<i<<j<<"=matrix_traits<A>::template r<"<<i<<','<<j<<">(a);"NL;
		g<<
			TAB3"T const f=scalar_traits<T>::one()/det;"NL
			TAB3"typedef typename deduce_matrix<A>::type R;"NL
			TAB3"R r;"NL
			;
		for( int i=0; i!=d; ++i )
			for( int j=0; j!=d; ++j )
				{
				g<<TAB3"matrix_traits<R>::template w<"<<i<<','<<j<<">(r)="<<(((i+j)&1)?'-':' ')<<"f*";
				determinant_impl(*g,d-1,delrc(delrc('a'),j,i));
				g<<";"NL;
				}
		g<<
			TAB3"return r;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	magnitude2( command_line_options const & opt, int d )
		{
		std::string dn=deduce_name("magnitude2","vector","");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		g<<INCLUDE_MATH;
		header_sr_va(*g,d,"magnitude2");
		g<<
			TAB3"{"NL
			TAB3"typedef typename vector_traits<A>::scalar_type T;"NL
			;
		for( int i=0; i!=d; ++i )
			g<<TAB3"T const a"<<i<<"=vector_traits<A>::template r<"<<i<<">(a);"NL;
		g<<TAB3"T const mag2=";
		for( int i=0; i!=d; ++i )
			{
			if( i )
				g<<'+';
			g<<'a'<<i<<"*a"<<i;
			}
		g<<
			";"NL
			TAB3"return mag2;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	magnitude( command_line_options const & opt, int d )
		{
		std::string dn=deduce_name("magnitude","vector","");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		g<<INCLUDE_MATH;
		header_sr_va(*g,d,"magnitude");
		g<<
			TAB3"{"NL
			TAB3"typedef typename vector_traits<A>::scalar_type T;"NL
			;
		for( int i=0; i!=d; ++i )
			g<<TAB3"T const a"<<i<<"=vector_traits<A>::template r<"<<i<<">(a);"NL;
		g<<TAB3"T const mag2=";
		for( int i=0; i!=d; ++i )
			{
			if( i )
				g<<'+';
			g<<'a'<<i<<"*a"<<i;
			}
		g<<
			";"NL
			TAB3"T const mag=sqrt<T>(mag2);"NL
			TAB3"return mag;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	void
	dot( command_line_options const & opt, int d )
		{
		std::string dn=deduce_name("dot","vector","");
		boost::shared_ptr<std::ostream> g=opt.stream(dn,d);
		header_sr_va_vb(*g,d,"dot");
		g<<
			TAB3"{"NL
			TAB3"typedef typename vector_traits<A>::scalar_type Ta;"NL
			TAB3"typedef typename vector_traits<B>::scalar_type Tb;"NL
			TAB3"typedef typename deduce_scalar<Ta,Tb>::type Tr;"NL
			;
		for( int i=0; i!=d; ++i )
			g<<TAB3"Ta const a"<<i<<"=vector_traits<A>::template r<"<<i<<">(a);"NL;
		for( int i=0; i!=d; ++i )
			g<<TAB3"Tb const b"<<i<<"=vector_traits<B>::template r<"<<i<<">(b);"NL;
		g<<TAB3"Tr const dot=";
		for( int i=0; i!=d; ++i )
			{
			if( i )
				g<<'+';
			g<<'a'<<i<<"*b"<<i;
			}
		g<<
			";"NL
			TAB3"return dot;"NL
			TAB3"}"NL
			;
		defined(*g,d,dn);
		g<<FOOTER;
		}

	template <int N>
	void
	swizzle_impl( std::ostream & g, int d, char const * (&ids)[N][2], std::vector<int> const & initial_count )
		{
		assert(d>=1);
		std::vector<int> count(initial_count);
		bool first=true;
		for( ;; )
			{
			if( !first )
				g<<NL;
			first=false;
			g<<TAB2"BOOST_LA_INLINE_TRIVIAL"NL TAB2;
			for( int k=0; k!=d; ++k )
				g<<(k?",":"")<<"la_detail::swizzle_idx<la_detail::swizzle_tag<"<<ids[count[k]-1][1]<<">::value";
			for( int k=0; k!=d; ++k )
				g<<" >";
			g<<NL TAB2;
			for( int k=0; k!=d; ++k )
				{
				char const * f=ids[count[k]-1][0];
				if( !k && f[0]>='0' && f[0]<='9' )
					g<<'_';
				g<<f;
				}
			g<<"() { return ";
			for( int k=0; k!=d; ++k )
				g<<(k?",":"")<<"la_detail::swizzle_idx<la_detail::swizzle_tag<"<<ids[count[k]-1][1]<<">::value";
			for( int k=0; k!=d; ++k )
				g<<" >";
			g<<"(); }"NL;
			int j;
			for( j=0; j!=d; ++j )
				if( --count[j] )
					break;
				else
					count[j]=initial_count[j];
			if( j==d )
				break;
			}
		}

	void
	swizzle( command_line_options const & opt, int d )
		{
		boost::shared_ptr<std::ostream> g=opt.stream("swizzle",d);
		g<<
			INCLUDE_SWIZZLE_TRAITS
			NL
			NAMESPACE_BEGIN
			;
		char const * swizzle_ids[6][2] =
			{
				{"X","_x_"},
				{"Y","_y_"},
				{"Z","_z_"},
				{"W","_w_"},
				{"0","_0_"},
				{"1","_1_"}
			};
		std::vector<int> initial_count(d,4);
		if( d>1 )
			initial_count[d-1]=6;
		swizzle_impl(*g,d,swizzle_ids,initial_count);
		g<<FOOTER;
		}

	command_line_options
	parse_command_line( int argc, char const * argv[] )
		{
		class
		next
			{
			char const * const * const argv;
			public:
			int const argc;
			next( int argc, char const * argv[] ):
				argc(argc),
				argv(argv)
				{
				}
			std::string
			operator()( int & i ) const
				{
				assert(i<argc);
				if( ++i==argc )
					BOOST_THROW_EXCEPTION(bad_command_line() << cmd_arg(argv[i-1]));
				return argv[i];
				}						 
			} next_token(argc,argv);
		command_line_options r;
		for( int i=1; i!=argc; ++i )
			if( argv[i][0]=='-' )
				{
				char const * arg=argv[i];
				if( arg==std::string("-od") )
					r.output_directory=next_token(i);
				else if( arg==std::string("-con") )
					r.con=true;
				else
					BOOST_THROW_EXCEPTION(bad_command_line() << cmd_arg(arg));
				}
		return r;
		}
	}

int
main( int argc, char const * argv[] )
	{
	command_line_options opt=parse_command_line(argc,argv);
	for( int d=2; d!=5; ++d )
		{
		mr_op_ma_mb_same_size(opt,d,d,"operator+","+");
		mr_op_ma_mb_same_size(opt,d,1,"operator+","+");
		mr_op_ma_mb_same_size(opt,1,d,"operator+","+");

		mr_op_ma_mb_same_size(opt,d,d,"operator-","-");
		mr_op_ma_mb_same_size(opt,d,1,"operator-","-");
		mr_op_ma_mb_same_size(opt,1,d,"operator-","-");

		ma_op_ma_mb_same_size(opt,d,d,"operator+=","+=");
		ma_op_ma_mb_same_size(opt,d,1,"operator+=","+=");
		ma_op_ma_mb_same_size(opt,1,d,"operator+=","+=");

		ma_op_ma_mb_same_size(opt,d,d,"operator-=","-=");
		ma_op_ma_mb_same_size(opt,d,1,"operator-=","-=");
		ma_op_ma_mb_same_size(opt,1,d,"operator-=","-=");

		mr_op_ma_sb(opt,d,d,"operator*","*");
		mr_op_ma_sb(opt,d,1,"operator*","*");
		mr_op_ma_sb(opt,1,d,"operator*","*");

		ma_op_ma_sb(opt,d,d,"operator*=","*=");
		ma_op_ma_sb(opt,d,1,"operator*=","*=");
		ma_op_ma_sb(opt,1,d,"operator*=","*=");

		mr_op_ma_sb(opt,d,d,"operator/","/");
		mr_op_ma_sb(opt,d,1,"operator/","/");
		mr_op_ma_sb(opt,1,d,"operator/","/");

		ma_op_ma_sb(opt,d,d,"operator/=","/=");
		ma_op_ma_sb(opt,d,1,"operator/=","/=");
		ma_op_ma_sb(opt,1,d,"operator/=","/=");

		ma_assign_ma_mb(opt,d,d);
		ma_assign_ma_mb(opt,d,1);
		ma_assign_ma_mb(opt,1,d);

		mr_make_ma(opt,d,d);
		mr_make_ma(opt,d,1);
		mr_make_ma(opt,1,d);

		bool_eq_ma_mb(opt,d,d);
		bool_eq_ma_mb(opt,d,1);
		bool_eq_ma_mb(opt,1,d);

		bool_neq_ma_mb(opt,d,d);
		bool_neq_ma_mb(opt,d,1);
		bool_neq_ma_mb(opt,1,d);

		mr_op_ma(opt,d,d,"operator-","-");
		mr_op_ma(opt,d,1,"operator-","-");
		mr_op_ma(opt,1,d,"operator-","-");

		determinant(opt,d);

		inverse_ma(opt,d);

		mr_mult_ma_mb(opt,d,d,d);
		mr_mult_ma_mb(opt,d,d,1);
		mr_mult_ma_mb(opt,1,d,d);

		ma_mult_ma_mb(opt,d);

		vr_op_va_vb_same_size(opt,d,"operator+","+");
		vr_op_va_vb_same_size(opt,d,"operator-","-");
		va_op_va_vb_same_size(opt,d,"operator+=","+=");
		va_op_va_vb_same_size(opt,d,"operator-=","-=");
		vr_op_va_sb(opt,d,"operator*","*");
		va_op_va_sb(opt,d,"operator*=","*=");
		vr_op_va_sb(opt,d,"operator/","/");
		va_op_va_sb(opt,d,"operator/=","/=");
		va_assign_va_vb(opt,d);
		vr_make_va(opt,d);
		vr_mult_ma_vb(opt,d,d);
		vr_mult_va_mb(opt,d,d);
		bool_eq_va_vb(opt,d);
		bool_neq_va_vb(opt,d);
		vr_op_va(opt,d,"operator-","-");
		magnitude(opt,d);
		magnitude2(opt,d);
		dot(opt,d);
		}
	swizzle(opt,2);
	swizzle(opt,3);
	swizzle(opt,4);
	opt.out_gen_headers();
	return 1;
	}
